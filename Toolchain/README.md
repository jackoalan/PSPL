PSPL Toolchain
==============

The **Toolchain** portion of PSPL includes development tools
necessary to *compile* and *package* PSPL source intermediates.
Just like the *PSPL Runtime*, the *PSPL Toolchain* may be extended
to support new functionality end-to-end. 

The toolchain shares the same extension namespace as the runtime,
so extensions may be written to extend both at the same time.

If you're less interested in build-system integration, and more interested
in using PSPL as a simple compiler, 
[skip to the **Toolchain Driver Usage** section](#toolchain-driver-usage).
In particular, read up on the *packaging mode*. 


PSPL Build System Integration
-----------------------------

The **PSPL Driver** is being designed with [CMake](http://cmake.org) integration in mind.
A typical CMake `make` invocation performs the following tasks:

* Gather *targets* previously defined in `CMakeLists.txt` tree
* Perform *dependency resolution* on targets
    * Determine if any individual *object files* are outdated from source files (or have yet to be built)
    * Build only the outdated objects and save the resulting files in a dedicated *build directory*
    * If outdated objects were present, invoke the *linker* (tying all objects together) and save the final product in the build directory.


### Extending The Dependency Tree

A PSPL source has the ability to reference external file resources by
source-relative path. A PSPL toolchain extension may access the contents
of this referenced file, convert it, and emit a platform-dependent, hash-identified
version of the resource for packaging in a PSPLP. Anytime the referenced file is
modified *(e.g. a brush-stroke added to a PSD file and saved)*, the 
platform-dependent version is invalidated. Thus, dependency resolution gains an 
additional tier of complexity. 

In PSPL, this procedure is known as **Reference Processing**
(or **refproc** for short). The refproc procedure always occurs inline with
compilation, so the compiler will need to run each time a referenced file is modified.

From the perspective of CMake (which needs to be informed of *all* files
contributing to a target), a PSPL source file is just a flat-file with no notion
of external references. Therefore, a *special mode* is added to the PSPL driver.
This mode is called **Reference Gathering** (or simply **gathering**); activated
with the `-G` flag. 

In the *gathering* mode of the driver, a PSPL source file is provided as input and
compilation occurs as normal. During the standard compilation routines, toolchain
extensions will notify the toolchain core that a file in the filesystem is being
referenced (based on input provided by the shader author). As the toolchain
continues to run, PSPL gathers a list of all these referenced files and generates
a CMake-include file containing a list of these files. This file is created if it 
doesn't exist, and only modified if it's determined to contain outdated references. 
The referenced file list is *semicolon-delimited* which provides compatibility with
CMake's list mechanic. The include file also calls out to a macro invoking
`add_custom_command` and `add_custom_target`. This ensures that CMake acknowledges 
both the PSPL source file, and dependently referenced files. 


### Reference Processing Staging Area

Since platform-dependent asset conversion needs to take place during reference 
processing, the PSPL toolchain establishes a region of the filesystem called a 
**Staging Area**. By default, this staging area exists in the working directory 
when `pspl` is invoked. It may be overridden with the `-S` flag. The staging 
area consists of a **single directory named "PSPLFiles"**. 

The *PSPLFiles* directory contains output files generated by PSPL toolchain 
extensions which have been renamed to the file's SHA1 hash. The hashing
mechanic ensures that PSPL's packager doesn't reference and store redundant
data.


Toolchain Driver Usage
----------------------

Now that an end-to-end dependency resolution method is defined, the toolchain driver 
usage modes become clear. Similar to C's *object compiling* and *linking* conventions, 
*PSPLC compiling (plus refproc)* and *PSPLP packaging* are analogically available.


### Command Synopsis

```
pspl [-o out-path] [-E|-c] [-G reflist-out-path] [-S staging-root-path] [-D def-name[=def-value]]... [-T target-platform]... [-e <LITTLE,BIG,BI>] source1 [source2 [sourceN]]...
```


### Packaging Mode

The default behaviour of PSPL is its **Packaging Mode**.
The packaging mode accepts multiple input files; either *source* (PSPL) 
and/or *compiled* (PSPLC) files may be provided to packaging mode. 
For PSPL sources, packaging mode performs end-to-end *preprocessing*, 
*compiling*, *refproc* and *packaging*. PSPLC files will *only be packaged*
into the final package (similar to linking .o files with a C compiler-toolchain). 

**Please Note:** When providing PSPLC files to Packaging Mode, refproc
*will not occur* and post-converted assets are expected to be already 
present into the staging-area used by `pspl` during packaging. A packaging
error will occur otherwise.

To use packaging mode, simply *omit* any `-E` and `-c` flags from the `pspl`
invocation.


### Preprocessor Only (`-E`)

In situations where a shader author or extension developer wishes to observe the
effects of the toolchain's preprocessor, a **preprocessor-only mode** is
available (`-E` flag). The output result will be a syntactically valid
PSPL source file with preprocessor directives expanded. 

**Please Note:** With preprocessor-only mode, *only the first* provided PSPL 
source is used.


### Compile To PSPLC Only (`-c`)

In large projects, a sparse, dependency-resolved build tree is desirable 
(perhaps established with the CMake art-pipeline macros). With the **compile-only mode**
(`-c` flag), a single PSPLC *compiled binary* is emitted rather than a complete
package.

**Please Note:** With compile-only mode, *only the first* provided PSPL source
is used.


### Toolchain Definitions (`-D def-name[=def-value]`)

Optionally, **defined toolchain variables** may be specified to the driver (`-D` flag).
The definitions are available in the *preprocessor* and *compiler* modes; 
granting flexible options for generating specially-built PSPLC objects.


### Target Platform(s) (`-T platform-name`)

Since PSPL is able to target a wide variety of graphics platforms, there is an
argument (`-T` flag) to select *one or more* **target platforms**. The toolchain driver
will emit packages or compiled objects for the selected platform(s). The name of the 
platform is case-sensitive, and the user must select one from the list presented in 
the built-in-help of `pspl` (run with no arguments or `-h`).

To target multiple platforms, repeat the `-T` flag for each platform. 

Note that it is valid to generate *platform-free* PSPL files by not using this option.
Platform-free files will not be bindable using the PSPL runtime's common shader
binding API. This may be used to create functional PSPL packages that 
*have nothing to do with shaders*. In these cases, the functionality relies on 
a comprehensive usage of PSPL extensions. The file-packaging mechanic of PSPL continues
to be available.


### Default Endianness (`-e <LITTLE,BIG,BI>`)

Some rigidly-defined graphics platforms specify a platform-native byte-order. For example,
*GX* enforces big-endian as its byte-order since it's guaranteed to be running on PowerPC
set in big-endian mode. In these cases, the PSPL byte order is implied when the relevant target
platform is selected.

More general graphics platforms (like *OpenGL*) have not specified a "native" byte-order
(since the standard is able to be implemented on both byte-orderings). In these cases,
PSPL will select byte-ordering based on the CPU the 
*Toolchain is currently running on*. 

If the byte-order of the Toolchain machine *does not match* the byte-order of the target 
runtime machine, the `-e` flag may be used to manually specify the byte-order that should
be used for generating the PSPL files. The value of the argument should be one of [LITTLE,BIG,BI].


### Output Path (`-o out-path`)

Simply enough, the PSPL toolchain driver will route **output** to `stdout` by 
default. If the `-o` flag and argument is provided, then the result is written into
a specified file instead.


### Reference Gathering (`-G reflist-out-path`)

For build systems that need to perform 
[extended dependency resolution via PSPL](#extending-the-dependency-tree),
the `-G` flag will write a complete *semicolon-delimited* relative-path 
**list of files** referenced within the PSPL source to the argument provided.

**Please Note:** Reference Gathering may *not* be combined with preprocess-only mode (`-E`).


### Reference Processing Staging Area (`-S staging-root-path`)

In a project where PSPL files may exist across an arbitrary tree of 
subdirectories, but end up being packaged into a single PSPLP, Reference
Processed output files need to be gathered into a **common staging area**
for the packager 

